// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/gitslim/chunkr-ai-sdk/sdk/go/core"
	time "time"
)

// Controls the processing and generation for the segment.
//   - `crop_image` controls whether to crop the file's images to the segment's bounding box.
//     The cropped image will be stored in the segment's `image` field. Use `All` to always crop,
//     or `Auto` to only crop when needed for post-processing.
//   - `html` is the HTML output for the segment, generated either through heuristic (`Auto`) or using Chunkr fine-tuned models (`LLM`)
//   - `llm` is the LLM-generated output for the segment, this uses off-the-shelf models to generate a custom output for the segment
//   - `markdown` is the Markdown output for the segment, generated either through heuristic (`Auto`) or using Chunkr fine-tuned models (`LLM`)
//   - `embed_sources` defines which content sources will be included in the chunk's embed field and counted towards the chunk length.
//     The array's order determines the sequence in which content appears in the embed field (e.g., [Markdown, LLM] means Markdown content
//     is followed by LLM content). This directly affects what content is available for embedding and retrieval.
type AutoGenerationConfig struct {
	CropImage    *CroppingStrategy `json:"crop_image,omitempty"`
	EmbedSources []EmbedSource     `json:"embed_sources,omitempty"`
	// Use the full page image as context for LLM generation
	ExtendedContext *bool               `json:"extended_context,omitempty"`
	Html            *GenerationStrategy `json:"html,omitempty"`
	Llm             *string             `json:"llm,omitempty"`
	Markdown        *GenerationStrategy `json:"markdown,omitempty"`

	_rawJSON json.RawMessage
}

func (a *AutoGenerationConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler AutoGenerationConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutoGenerationConfig(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutoGenerationConfig) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Bounding box for an item. It is used for chunks, segments and OCR results.
type BoundingBox struct {
	// The height of the bounding box.
	Height float64 `json:"height"`
	// The left coordinate of the bounding box.
	Left float64 `json:"left"`
	// The top coordinate of the bounding box.
	Top float64 `json:"top"`
	// The width of the bounding box.
	Width float64 `json:"width"`

	_rawJSON json.RawMessage
}

func (b *BoundingBox) UnmarshalJSON(data []byte) error {
	type unmarshaler BoundingBox
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BoundingBox(value)
	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BoundingBox) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Chunk struct {
	// The unique identifier for the chunk.
	ChunkId *string `json:"chunk_id,omitempty"`
	// The total number of tokens in the chunk. Calculated by the `tokenizer`.
	ChunkLength int `json:"chunk_length"`
	// Suggested text to be embedded for the chunk. This text is generated by combining the embed content
	// from each segment according to the configured embed sources (HTML, Markdown, LLM, or Content).
	// Can be configured using `embed_sources` in the `SegmentProcessing` configuration.
	Embed *string `json:"embed,omitempty"`
	// Collection of document segments that form this chunk.
	// When `target_chunk_length` > 0, contains the maximum number of segments
	// that fit within that length (segments remain intact).
	// Otherwise, contains exactly one segment.
	Segments []*Segment `json:"segments,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Chunk) UnmarshalJSON(data []byte) error {
	type unmarshaler Chunk
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Chunk(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Chunk) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Controls the setting for the chunking and post-processing of each chunk.
type ChunkProcessing struct {
	// Whether to ignore headers and footers in the chunking process.
	// This is recommended as headers and footers break reading order across pages.
	IgnoreHeadersAndFooters *bool `json:"ignore_headers_and_footers,omitempty"`
	// The target number of words in each chunk. If 0, each chunk will contain a single segment.
	TargetLength *int           `json:"target_length,omitempty"`
	Tokenizer    *TokenizerType `json:"tokenizer,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChunkProcessing) UnmarshalJSON(data []byte) error {
	type unmarshaler ChunkProcessing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChunkProcessing(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChunkProcessing) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Configuration struct {
	ChunkProcessing *ChunkProcessing      `json:"chunk_processing,omitempty"`
	ErrorHandling   ErrorHandlingStrategy `json:"error_handling,omitempty"`
	// The number of seconds until task is deleted.
	// Expired tasks can **not** be updated, polled or accessed via web interface.
	ExpiresIn *int `json:"expires_in,omitempty"`
	// Whether to use high-resolution images for cropping and post-processing.
	HighResolution bool `json:"high_resolution"`
	// The presigned URL of the input file.
	InputFileUrl         *string              `json:"input_file_url,omitempty"`
	JsonSchema           interface{}          `json:"json_schema,omitempty"`
	LlmProcessing        *LlmProcessing       `json:"llm_processing,omitempty"`
	Model                *Model               `json:"model,omitempty"`
	OcrStrategy          OcrStrategy          `json:"ocr_strategy,omitempty"`
	SegmentProcessing    *SegmentProcessing   `json:"segment_processing,omitempty"`
	SegmentationStrategy SegmentationStrategy `json:"segmentation_strategy,omitempty"`
	// The target number of words in each chunk. If 0, each chunk will contain a single segment.
	TargetChunkLength *int `json:"target_chunk_length,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Configuration) UnmarshalJSON(data []byte) error {
	type unmarshaler Configuration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Configuration(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Configuration) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateFormMultipart struct {
	ChunkProcessing *ChunkProcessing `json:"chunk_processing,omitempty"`
	// The number of seconds until task is deleted.
	// Expired tasks can **not** be updated, polled or accessed via web interface.
	ExpiresIn *int `json:"expires_in,omitempty"`
	// The file to be uploaded.
	File string `json:"file"`
	// Whether to use high-resolution images for cropping and post-processing. (Latency penalty: ~7 seconds per page)
	HighResolution       *bool                 `json:"high_resolution,omitempty"`
	OcrStrategy          *OcrStrategy          `json:"ocr_strategy,omitempty"`
	SegmentProcessing    *SegmentProcessing    `json:"segment_processing,omitempty"`
	SegmentationStrategy *SegmentationStrategy `json:"segmentation_strategy,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateFormMultipart) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateFormMultipart
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateFormMultipart(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateFormMultipart) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Controls the cropping strategy for an item (e.g. segment, chunk, etc.)
// - `All` crops all images in the item
// - `Auto` crops images only if required for post-processing
type CroppingStrategy string

const (
	CroppingStrategyAll  CroppingStrategy = "All"
	CroppingStrategyAuto CroppingStrategy = "Auto"
)

func NewCroppingStrategyFromString(s string) (CroppingStrategy, error) {
	switch s {
	case "All":
		return CroppingStrategyAll, nil
	case "Auto":
		return CroppingStrategyAuto, nil
	}
	var t CroppingStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CroppingStrategy) Ptr() *CroppingStrategy {
	return &c
}

type EmbedSource string

const (
	EmbedSourceHtml     EmbedSource = "HTML"
	EmbedSourceMarkdown EmbedSource = "Markdown"
	EmbedSourceLlm      EmbedSource = "LLM"
	EmbedSourceContent  EmbedSource = "Content"
)

func NewEmbedSourceFromString(s string) (EmbedSource, error) {
	switch s {
	case "HTML":
		return EmbedSourceHtml, nil
	case "Markdown":
		return EmbedSourceMarkdown, nil
	case "LLM":
		return EmbedSourceLlm, nil
	case "Content":
		return EmbedSourceContent, nil
	}
	var t EmbedSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedSource) Ptr() *EmbedSource {
	return &e
}

// Controls how errors are handled during processing:
// - `Fail`: Stops processing and fails the task when any error occurs
// - `Continue`: Attempts to continue processing despite non-critical errors (eg. LLM refusals etc.)
type ErrorHandlingStrategy string

const (
	ErrorHandlingStrategyFail     ErrorHandlingStrategy = "Fail"
	ErrorHandlingStrategyContinue ErrorHandlingStrategy = "Continue"
)

func NewErrorHandlingStrategyFromString(s string) (ErrorHandlingStrategy, error) {
	switch s {
	case "Fail":
		return ErrorHandlingStrategyFail, nil
	case "Continue":
		return ErrorHandlingStrategyContinue, nil
	}
	var t ErrorHandlingStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorHandlingStrategy) Ptr() *ErrorHandlingStrategy {
	return &e
}

// Specifies the fallback strategy for LLM processing
//
// This can be:
// 1. None - No fallback will be used
// 2. Default - The system default fallback model will be used
// 3. Model - A specific model ID will be used as fallback (check the documentation for the models.)
type FallbackStrategy struct {
	typeName             string
	NoneStringLiteral    string
	DefaultStringLiteral string
	// Use a specific model as fallback
	FallbackStrategyModel *FallbackStrategyModel
}

func NewFallbackStrategyWithNoneStringLiteral() *FallbackStrategy {
	return &FallbackStrategy{typeName: "noneStringLiteral", NoneStringLiteral: "None"}
}

func NewFallbackStrategyWithDefaultStringLiteral() *FallbackStrategy {
	return &FallbackStrategy{typeName: "defaultStringLiteral", DefaultStringLiteral: "Default"}
}

func NewFallbackStrategyFromFallbackStrategyModel(value *FallbackStrategyModel) *FallbackStrategy {
	return &FallbackStrategy{typeName: "fallbackStrategyModel", FallbackStrategyModel: value}
}

func (f *FallbackStrategy) NoneStringLiteral() string {
	return f.NoneStringLiteral
}

func (f *FallbackStrategy) DefaultStringLiteral() string {
	return f.DefaultStringLiteral
}

func (f *FallbackStrategy) UnmarshalJSON(data []byte) error {
	var valueNoneStringLiteral string
	if err := json.Unmarshal(data, &valueNoneStringLiteral); err == nil {
		if valueNoneStringLiteral == "None" {
			f.typeName = "noneStringLiteral"
			f.NoneStringLiteral = valueNoneStringLiteral
			return nil
		}
	}
	var valueDefaultStringLiteral string
	if err := json.Unmarshal(data, &valueDefaultStringLiteral); err == nil {
		if valueDefaultStringLiteral == "Default" {
			f.typeName = "defaultStringLiteral"
			f.DefaultStringLiteral = valueDefaultStringLiteral
			return nil
		}
	}
	valueFallbackStrategyModel := new(FallbackStrategyModel)
	if err := json.Unmarshal(data, &valueFallbackStrategyModel); err == nil {
		f.typeName = "fallbackStrategyModel"
		f.FallbackStrategyModel = valueFallbackStrategyModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackStrategy) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "noneStringLiteral":
		return json.Marshal("None")
	case "defaultStringLiteral":
		return json.Marshal("Default")
	case "fallbackStrategyModel":
		return json.Marshal(f.FallbackStrategyModel)
	}
}

type FallbackStrategyVisitor interface {
	VisitNoneStringLiteral(string) error
	VisitDefaultStringLiteral(string) error
	VisitFallbackStrategyModel(*FallbackStrategyModel) error
}

func (f *FallbackStrategy) Accept(visitor FallbackStrategyVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "noneStringLiteral":
		return visitor.VisitNoneStringLiteral(f.NoneStringLiteral)
	case "defaultStringLiteral":
		return visitor.VisitDefaultStringLiteral(f.DefaultStringLiteral)
	case "fallbackStrategyModel":
		return visitor.VisitFallbackStrategyModel(f.FallbackStrategyModel)
	}
}

// Use a specific model as fallback
type FallbackStrategyModel struct {
	// Use a specific model as fallback
	Model string `json:"Model"`

	_rawJSON json.RawMessage
}

func (f *FallbackStrategyModel) UnmarshalJSON(data []byte) error {
	type unmarshaler FallbackStrategyModel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FallbackStrategyModel(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackStrategyModel) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type GenerationStrategy string

const (
	GenerationStrategyLlm  GenerationStrategy = "LLM"
	GenerationStrategyAuto GenerationStrategy = "Auto"
)

func NewGenerationStrategyFromString(s string) (GenerationStrategy, error) {
	switch s {
	case "LLM":
		return GenerationStrategyLlm, nil
	case "Auto":
		return GenerationStrategyAuto, nil
	}
	var t GenerationStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenerationStrategy) Ptr() *GenerationStrategy {
	return &g
}

// Controls the processing and generation for the segment.
//   - `crop_image` controls whether to crop the file's images to the segment's bounding box.
//     The cropped image will be stored in the segment's `image` field. Use `All` to always crop,
//     or `Auto` to only crop when needed for post-processing.
//   - `html` is the HTML output for the segment, generated either through huerstics (`Auto`) or using Chunkr fine-tuned models (`LLM`)
//   - `llm` is the LLM-generated output for the segment, this uses off-the-shelf models to generate a custom output for the segment
//   - `markdown` is the Markdown output for the segment, generated either through huerstics (`Auto`) or using Chunkr fine-tuned models (`LLM`)
//   - `embed_sources` defines which content sources will be included in the chunk's embed field and counted towards the chunk length.
//     The array's order determines the sequence in which content appears in the embed field (e.g., [Markdown, LLM] means Markdown content
//     is followed by LLM content). This directly affects what content is available for embedding and retrieval.
type LlmGenerationConfig struct {
	CropImage    *CroppingStrategy `json:"crop_image,omitempty"`
	EmbedSources []EmbedSource     `json:"embed_sources,omitempty"`
	// Use the full page image as context for LLM generation
	ExtendedContext *bool               `json:"extended_context,omitempty"`
	Html            *GenerationStrategy `json:"html,omitempty"`
	// Prompt for the LLM model
	Llm      *string             `json:"llm,omitempty"`
	Markdown *GenerationStrategy `json:"markdown,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LlmGenerationConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler LlmGenerationConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LlmGenerationConfig(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LlmGenerationConfig) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Controls the LLM used for the task.
type LlmProcessing struct {
	// The fallback strategy to use for the LLMs in the task.
	FallbackStrategy *FallbackStrategy `json:"fallback_strategy,omitempty"`
	// The maximum number of tokens to generate.
	MaxCompletionTokens *int `json:"max_completion_tokens,omitempty"`
	// The ID of the model to use for the task. If not provided, the default model will be used.
	// Please check the documentation for the model you want to use.
	ModelId *string `json:"model_id,omitempty"`
	// The temperature to use for the LLM.
	Temperature *float64 `json:"temperature,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LlmProcessing) UnmarshalJSON(data []byte) error {
	type unmarshaler LlmProcessing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LlmProcessing(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LlmProcessing) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Model string

const (
	ModelFast        Model = "Fast"
	ModelHighQuality Model = "HighQuality"
)

func NewModelFromString(s string) (Model, error) {
	switch s {
	case "Fast":
		return ModelFast, nil
	case "HighQuality":
		return ModelHighQuality, nil
	}
	var t Model
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m Model) Ptr() *Model {
	return &m
}

// OCR results for a segment
type OcrResult struct {
	Bbox *BoundingBox `json:"bbox,omitempty"`
	// The confidence score of the recognized text.
	Confidence *float64 `json:"confidence,omitempty"`
	// The recognized text of the OCR result.
	Text string `json:"text"`

	_rawJSON json.RawMessage
}

func (o *OcrResult) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrResult(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrResult) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Controls the Optical Character Recognition (OCR) strategy.
// - `All`: Processes all pages with OCR. (Latency penalty: ~0.5 seconds per page)
// - `Auto`: Selectively applies OCR only to pages with missing or low-quality text. When text layer is present the bounding boxes from the text layer are used.
type OcrStrategy string

const (
	OcrStrategyAll  OcrStrategy = "All"
	OcrStrategyAuto OcrStrategy = "Auto"
)

func NewOcrStrategyFromString(s string) (OcrStrategy, error) {
	switch s {
	case "All":
		return OcrStrategyAll, nil
	case "Auto":
		return OcrStrategyAuto, nil
	}
	var t OcrStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OcrStrategy) Ptr() *OcrStrategy {
	return &o
}

// The processed results of a document analysis task
type OutputResponse struct {
	// Collection of document chunks, where each chunk contains one or more segments
	Chunks        []*Chunk    `json:"chunks,omitempty"`
	ExtractedJson interface{} `json:"extracted_json,omitempty"`
	// The name of the file.
	FileName *string `json:"file_name,omitempty"`
	// The number of pages in the file.
	PageCount *int `json:"page_count,omitempty"`
	// The presigned URL of the PDF file.
	PdfUrl *string `json:"pdf_url,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OutputResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OutputResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OutputResponse(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OutputResponse) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Controls the cropping strategy for an item (e.g. segment, chunk, etc.)
// - `All` crops all images in the item
// - `Auto` crops images only if required for post-processing
type PictureCroppingStrategy string

const (
	PictureCroppingStrategyAll  PictureCroppingStrategy = "All"
	PictureCroppingStrategyAuto PictureCroppingStrategy = "Auto"
)

func NewPictureCroppingStrategyFromString(s string) (PictureCroppingStrategy, error) {
	switch s {
	case "All":
		return PictureCroppingStrategyAll, nil
	case "Auto":
		return PictureCroppingStrategyAuto, nil
	}
	var t PictureCroppingStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PictureCroppingStrategy) Ptr() *PictureCroppingStrategy {
	return &p
}

// Controls the processing and generation for the segment.
//   - `crop_image` controls whether to crop the file's images to the segment's bounding box.
//     The cropped image will be stored in the segment's `image` field. Use `All` to always crop,
//     or `Auto` to only crop when needed for post-processing.
//   - `html` is the HTML output for the segment, generated either through heuristic (`Auto`) or using Chunkr fine-tuned models (`LLM`)
//   - `llm` is the LLM-generated output for the segment, this uses off-the-shelf models to generate a custom output for the segment
//   - `markdown` is the Markdown output for the segment, generated either through heuristic (`Auto`) or using Chunkr fine-tuned models (`LLM`)
//   - `embed_sources` defines which content sources will be included in the chunk's embed field and counted towards the chunk length.
//     The array's order determines the sequence in which content appears in the embed field (e.g., [Markdown, LLM] means Markdown content
//     is followed by LLM content). This directly affects what content is available for embedding and retrieval.
type PictureGenerationConfig struct {
	CropImage    *PictureCroppingStrategy `json:"crop_image,omitempty"`
	EmbedSources []EmbedSource            `json:"embed_sources,omitempty"`
	// Use the full page image as context for LLM generation
	ExtendedContext *bool               `json:"extended_context,omitempty"`
	Html            *GenerationStrategy `json:"html,omitempty"`
	// Prompt for the LLM model
	Llm      *string             `json:"llm,omitempty"`
	Markdown *GenerationStrategy `json:"markdown,omitempty"`

	_rawJSON json.RawMessage
}

func (p *PictureGenerationConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler PictureGenerationConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PictureGenerationConfig(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PictureGenerationConfig) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Segment struct {
	Bbox *BoundingBox `json:"bbox,omitempty"`
	// Confidence score of the layout analysis model
	Confidence *float64 `json:"confidence,omitempty"`
	// Text content of the segment. Calculated by the OCR results.
	Content *string `json:"content,omitempty"`
	// HTML representation of the segment.
	Html *string `json:"html,omitempty"`
	// Presigned URL to the image of the segment.
	Image *string `json:"image,omitempty"`
	// LLM representation of the segment.
	Llm *string `json:"llm,omitempty"`
	// Markdown representation of the segment.
	Markdown *string `json:"markdown,omitempty"`
	// OCR results for the segment.
	Ocr []*OcrResult `json:"ocr,omitempty"`
	// Height of the page containing the segment.
	PageHeight float64 `json:"page_height"`
	// Page number of the segment.
	PageNumber int `json:"page_number"`
	// Width of the page containing the segment.
	PageWidth float64 `json:"page_width"`
	// Unique identifier for the segment.
	SegmentId   string      `json:"segment_id"`
	SegmentType SegmentType `json:"segment_type,omitempty"`

	_rawJSON json.RawMessage
}

func (s *Segment) UnmarshalJSON(data []byte) error {
	type unmarshaler Segment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Segment(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *Segment) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Controls the post-processing of each segment type.
// Allows you to generate HTML and Markdown from chunkr models for each segment type.
// By default, the HTML and Markdown are generated manually using the segmentation information except for `Table`, `Formula` and `Picture`.
// You can optionally configure custom LLM prompts and models to generate an additional `llm` field with LLM-processed content for each segment type.
//
// The configuration of which content sources (HTML, Markdown, LLM, Content) of the segment
// should be included in the chunk's `embed` field and counted towards the chunk length can be configured through the `embed_sources` setting.
type SegmentProcessing struct {
	Caption       *AutoGenerationConfig    `json:"Caption,omitempty"`
	Footnote      *AutoGenerationConfig    `json:"Footnote,omitempty"`
	Formula       *LlmGenerationConfig     `json:"Formula,omitempty"`
	ListItem      *AutoGenerationConfig    `json:"ListItem,omitempty"`
	Page          *LlmGenerationConfig     `json:"Page,omitempty"`
	PageFooter    *AutoGenerationConfig    `json:"PageFooter,omitempty"`
	PageHeader    *AutoGenerationConfig    `json:"PageHeader,omitempty"`
	Picture       *PictureGenerationConfig `json:"Picture,omitempty"`
	SectionHeader *AutoGenerationConfig    `json:"SectionHeader,omitempty"`
	Table         *LlmGenerationConfig     `json:"Table,omitempty"`
	Text          *AutoGenerationConfig    `json:"Text,omitempty"`
	Title         *AutoGenerationConfig    `json:"Title,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SegmentProcessing) UnmarshalJSON(data []byte) error {
	type unmarshaler SegmentProcessing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SegmentProcessing(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SegmentProcessing) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// All the possible types for a segment.
// Note: Different configurations will produce different types.
// Please refer to the documentation for more information.
type SegmentType string

const (
	SegmentTypeCaption       SegmentType = "Caption"
	SegmentTypeFootnote      SegmentType = "Footnote"
	SegmentTypeFormula       SegmentType = "Formula"
	SegmentTypeListItem      SegmentType = "ListItem"
	SegmentTypePage          SegmentType = "Page"
	SegmentTypePageFooter    SegmentType = "PageFooter"
	SegmentTypePageHeader    SegmentType = "PageHeader"
	SegmentTypePicture       SegmentType = "Picture"
	SegmentTypeSectionHeader SegmentType = "SectionHeader"
	SegmentTypeTable         SegmentType = "Table"
	SegmentTypeText          SegmentType = "Text"
	SegmentTypeTitle         SegmentType = "Title"
)

func NewSegmentTypeFromString(s string) (SegmentType, error) {
	switch s {
	case "Caption":
		return SegmentTypeCaption, nil
	case "Footnote":
		return SegmentTypeFootnote, nil
	case "Formula":
		return SegmentTypeFormula, nil
	case "ListItem":
		return SegmentTypeListItem, nil
	case "Page":
		return SegmentTypePage, nil
	case "PageFooter":
		return SegmentTypePageFooter, nil
	case "PageHeader":
		return SegmentTypePageHeader, nil
	case "Picture":
		return SegmentTypePicture, nil
	case "SectionHeader":
		return SegmentTypeSectionHeader, nil
	case "Table":
		return SegmentTypeTable, nil
	case "Text":
		return SegmentTypeText, nil
	case "Title":
		return SegmentTypeTitle, nil
	}
	var t SegmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SegmentType) Ptr() *SegmentType {
	return &s
}

// Controls the segmentation strategy:
// - `LayoutAnalysis`: Analyzes pages for layout elements (e.g., `Table`, `Picture`, `Formula`, etc.) using bounding boxes. Provides fine-grained segmentation and better chunking. (Latency penalty: ~TBD seconds per page).
// - `Page`: Treats each page as a single segment. Faster processing, but without layout element detection and only simple chunking.
type SegmentationStrategy string

const (
	SegmentationStrategyLayoutAnalysis SegmentationStrategy = "LayoutAnalysis"
	SegmentationStrategyPage           SegmentationStrategy = "Page"
)

func NewSegmentationStrategyFromString(s string) (SegmentationStrategy, error) {
	switch s {
	case "LayoutAnalysis":
		return SegmentationStrategyLayoutAnalysis, nil
	case "Page":
		return SegmentationStrategyPage, nil
	}
	var t SegmentationStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SegmentationStrategy) Ptr() *SegmentationStrategy {
	return &s
}

// The status of the task.
type Status string

const (
	StatusStarting   Status = "Starting"
	StatusProcessing Status = "Processing"
	StatusSucceeded  Status = "Succeeded"
	StatusFailed     Status = "Failed"
	StatusCancelled  Status = "Cancelled"
)

func NewStatusFromString(s string) (Status, error) {
	switch s {
	case "Starting":
		return StatusStarting, nil
	case "Processing":
		return StatusProcessing, nil
	case "Succeeded":
		return StatusSucceeded, nil
	case "Failed":
		return StatusFailed, nil
	case "Cancelled":
		return StatusCancelled, nil
	}
	var t Status
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s Status) Ptr() *Status {
	return &s
}

type TaskResponse struct {
	Configuration *Configuration `json:"configuration,omitempty"`
	// The date and time when the task was created and queued.
	CreatedAt time.Time `json:"created_at"`
	// The date and time when the task will expire.
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
	// The date and time when the task was finished.
	FinishedAt *time.Time `json:"finished_at,omitempty"`
	// A message describing the task's status or any errors that occurred.
	Message string          `json:"message"`
	Output  *OutputResponse `json:"output,omitempty"`
	// The date and time when the task was started.
	StartedAt *time.Time `json:"started_at,omitempty"`
	Status    Status     `json:"status,omitempty"`
	// The unique identifier for the task.
	TaskId string `json:"task_id"`
	// The presigned URL of the task.
	TaskUrl *string `json:"task_url,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TaskResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TaskResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TaskResponse(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaskResponse) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Common tokenizers used for text processing.
//
// These values represent standard tokenization approaches and popular pre-trained
// tokenizers from the Hugging Face ecosystem.
type Tokenizer string

const (
	TokenizerWord            Tokenizer = "Word"
	TokenizerCl100KBase      Tokenizer = "Cl100kBase"
	TokenizerXlmRobertaBase  Tokenizer = "XlmRobertaBase"
	TokenizerBertBaseUncased Tokenizer = "BertBaseUncased"
)

func NewTokenizerFromString(s string) (Tokenizer, error) {
	switch s {
	case "Word":
		return TokenizerWord, nil
	case "Cl100kBase":
		return TokenizerCl100KBase, nil
	case "XlmRobertaBase":
		return TokenizerXlmRobertaBase, nil
	case "BertBaseUncased":
		return TokenizerBertBaseUncased, nil
	}
	var t Tokenizer
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t Tokenizer) Ptr() *Tokenizer {
	return &t
}

// Specifies which tokenizer to use for the chunking process.
//
// This type supports two ways of specifying a tokenizer:
//  1. Using a predefined tokenizer from the `Tokenizer` enum
//  2. Using any Hugging Face tokenizer by providing its model ID as a string
//     (e.g. "facebook/bart-large", "Qwen/Qwen-tokenizer", etc.)
//
// When using a string, any valid Hugging Face tokenizer ID can be specified,
// which will be loaded using the Hugging Face tokenizers library.
type TokenizerType struct {
	typeName string
	// Use one of the predefined tokenizer types
	TokenizerTypeEnum *TokenizerTypeEnum
	// Use any Hugging Face tokenizer by specifying its model ID
	// Examples: "Qwen/Qwen-tokenizer", "facebook/bart-large"
	TokenizerTypeString *TokenizerTypeString
}

func NewTokenizerTypeFromTokenizerTypeEnum(value *TokenizerTypeEnum) *TokenizerType {
	return &TokenizerType{typeName: "tokenizerTypeEnum", TokenizerTypeEnum: value}
}

func NewTokenizerTypeFromTokenizerTypeString(value *TokenizerTypeString) *TokenizerType {
	return &TokenizerType{typeName: "tokenizerTypeString", TokenizerTypeString: value}
}

func (t *TokenizerType) UnmarshalJSON(data []byte) error {
	valueTokenizerTypeEnum := new(TokenizerTypeEnum)
	if err := json.Unmarshal(data, &valueTokenizerTypeEnum); err == nil {
		t.typeName = "tokenizerTypeEnum"
		t.TokenizerTypeEnum = valueTokenizerTypeEnum
		return nil
	}
	valueTokenizerTypeString := new(TokenizerTypeString)
	if err := json.Unmarshal(data, &valueTokenizerTypeString); err == nil {
		t.typeName = "tokenizerTypeString"
		t.TokenizerTypeString = valueTokenizerTypeString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TokenizerType) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "tokenizerTypeEnum":
		return json.Marshal(t.TokenizerTypeEnum)
	case "tokenizerTypeString":
		return json.Marshal(t.TokenizerTypeString)
	}
}

type TokenizerTypeVisitor interface {
	VisitTokenizerTypeEnum(*TokenizerTypeEnum) error
	VisitTokenizerTypeString(*TokenizerTypeString) error
}

func (t *TokenizerType) Accept(visitor TokenizerTypeVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "tokenizerTypeEnum":
		return visitor.VisitTokenizerTypeEnum(t.TokenizerTypeEnum)
	case "tokenizerTypeString":
		return visitor.VisitTokenizerTypeString(t.TokenizerTypeString)
	}
}

// Use one of the predefined tokenizer types
type TokenizerTypeEnum struct {
	// Use one of the predefined tokenizer types
	Enum Tokenizer `json:"Enum,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TokenizerTypeEnum) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenizerTypeEnum
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenizerTypeEnum(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenizerTypeEnum) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Use any Hugging Face tokenizer by specifying its model ID
// Examples: "Qwen/Qwen-tokenizer", "facebook/bart-large"
type TokenizerTypeString struct {
	// Use any Hugging Face tokenizer by specifying its model ID
	// Examples: "Qwen/Qwen-tokenizer", "facebook/bart-large"
	String string `json:"String"`

	_rawJSON json.RawMessage
}

func (t *TokenizerTypeString) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenizerTypeString
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenizerTypeString(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenizerTypeString) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type UpdateFormMultipart struct {
	ChunkProcessing *ChunkProcessing `json:"chunk_processing,omitempty"`
	// The number of seconds until task is deleted.
	// Expried tasks can **not** be updated, polled or accessed via web interface.
	ExpiresIn *int `json:"expires_in,omitempty"`
	// Whether to use high-resolution images for cropping and post-processing. (Latency penalty: ~7 seconds per page)
	HighResolution       *bool                 `json:"high_resolution,omitempty"`
	OcrStrategy          *OcrStrategy          `json:"ocr_strategy,omitempty"`
	SegmentProcessing    *SegmentProcessing    `json:"segment_processing,omitempty"`
	SegmentationStrategy *SegmentationStrategy `json:"segmentation_strategy,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UpdateFormMultipart) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateFormMultipart
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateFormMultipart(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateFormMultipart) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
