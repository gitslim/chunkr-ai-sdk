// Code generated by Fern. DO NOT EDIT.

package chunkrai

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/gitslim/chunkr-ai-sdk/sdk/go/chunkrai/internal"
	time "time"
)

// Controls the processing and generation for the segment.
//   - `crop_image` controls whether to crop the file's images to the segment's bounding box.
//     The cropped image will be stored in the segment's `image` field. Use `All` to always crop,
//     or `Auto` to only crop when needed for post-processing.
//   - `html` is the HTML output for the segment, generated either through heuristic (`Auto`) or using Chunkr fine-tuned models (`LLM`)
//   - `llm` is the LLM-generated output for the segment, this uses off-the-shelf models to generate a custom output for the segment
//   - `markdown` is the Markdown output for the segment, generated either through heuristic (`Auto`) or using Chunkr fine-tuned models (`LLM`)
//   - `embed_sources` defines which content sources will be included in the chunk's embed field and counted towards the chunk length.
//     The array's order determines the sequence in which content appears in the embed field (e.g., [Markdown, LLM] means Markdown content
//     is followed by LLM content). This directly affects what content is available for embedding and retrieval.
type AutoGenerationConfig struct {
	CropImage    *CroppingStrategy `json:"crop_image,omitempty" url:"crop_image,omitempty"`
	EmbedSources []EmbedSource     `json:"embed_sources,omitempty" url:"embed_sources,omitempty"`
	// Use the full page image as context for LLM generation
	ExtendedContext *bool               `json:"extended_context,omitempty" url:"extended_context,omitempty"`
	Html            *GenerationStrategy `json:"html,omitempty" url:"html,omitempty"`
	Llm             *string             `json:"llm,omitempty" url:"llm,omitempty"`
	Markdown        *GenerationStrategy `json:"markdown,omitempty" url:"markdown,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AutoGenerationConfig) GetCropImage() *CroppingStrategy {
	if a == nil {
		return nil
	}
	return a.CropImage
}

func (a *AutoGenerationConfig) GetEmbedSources() []EmbedSource {
	if a == nil {
		return nil
	}
	return a.EmbedSources
}

func (a *AutoGenerationConfig) GetExtendedContext() *bool {
	if a == nil {
		return nil
	}
	return a.ExtendedContext
}

func (a *AutoGenerationConfig) GetHtml() *GenerationStrategy {
	if a == nil {
		return nil
	}
	return a.Html
}

func (a *AutoGenerationConfig) GetLlm() *string {
	if a == nil {
		return nil
	}
	return a.Llm
}

func (a *AutoGenerationConfig) GetMarkdown() *GenerationStrategy {
	if a == nil {
		return nil
	}
	return a.Markdown
}

func (a *AutoGenerationConfig) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AutoGenerationConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler AutoGenerationConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AutoGenerationConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AutoGenerationConfig) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Bounding box for an item. It is used for chunks, segments and OCR results.
type BoundingBox struct {
	// The height of the bounding box.
	Height float64 `json:"height" url:"height"`
	// The left coordinate of the bounding box.
	Left float64 `json:"left" url:"left"`
	// The top coordinate of the bounding box.
	Top float64 `json:"top" url:"top"`
	// The width of the bounding box.
	Width float64 `json:"width" url:"width"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BoundingBox) GetHeight() float64 {
	if b == nil {
		return 0
	}
	return b.Height
}

func (b *BoundingBox) GetLeft() float64 {
	if b == nil {
		return 0
	}
	return b.Left
}

func (b *BoundingBox) GetTop() float64 {
	if b == nil {
		return 0
	}
	return b.Top
}

func (b *BoundingBox) GetWidth() float64 {
	if b == nil {
		return 0
	}
	return b.Width
}

func (b *BoundingBox) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BoundingBox) UnmarshalJSON(data []byte) error {
	type unmarshaler BoundingBox
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BoundingBox(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BoundingBox) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type Chunk struct {
	// The unique identifier for the chunk.
	ChunkId *string `json:"chunk_id,omitempty" url:"chunk_id,omitempty"`
	// The total number of tokens in the chunk. Calculated by the `tokenizer`.
	ChunkLength int `json:"chunk_length" url:"chunk_length"`
	// Suggested text to be embedded for the chunk. This text is generated by combining the embed content
	// from each segment according to the configured embed sources (HTML, Markdown, LLM, or Content).
	// Can be configured using `embed_sources` in the `SegmentProcessing` configuration.
	Embed *string `json:"embed,omitempty" url:"embed,omitempty"`
	// Collection of document segments that form this chunk.
	// When `target_chunk_length` > 0, contains the maximum number of segments
	// that fit within that length (segments remain intact).
	// Otherwise, contains exactly one segment.
	Segments []*Segment `json:"segments" url:"segments"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Chunk) GetChunkId() *string {
	if c == nil {
		return nil
	}
	return c.ChunkId
}

func (c *Chunk) GetChunkLength() int {
	if c == nil {
		return 0
	}
	return c.ChunkLength
}

func (c *Chunk) GetEmbed() *string {
	if c == nil {
		return nil
	}
	return c.Embed
}

func (c *Chunk) GetSegments() []*Segment {
	if c == nil {
		return nil
	}
	return c.Segments
}

func (c *Chunk) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Chunk) UnmarshalJSON(data []byte) error {
	type unmarshaler Chunk
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Chunk(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Chunk) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Controls the setting for the chunking and post-processing of each chunk.
type ChunkProcessing struct {
	// Whether to ignore headers and footers in the chunking process.
	// This is recommended as headers and footers break reading order across pages.
	IgnoreHeadersAndFooters *bool `json:"ignore_headers_and_footers,omitempty" url:"ignore_headers_and_footers,omitempty"`
	// The target number of words in each chunk. If 0, each chunk will contain a single segment.
	TargetLength *int           `json:"target_length,omitempty" url:"target_length,omitempty"`
	Tokenizer    *TokenizerType `json:"tokenizer,omitempty" url:"tokenizer,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ChunkProcessing) GetIgnoreHeadersAndFooters() *bool {
	if c == nil {
		return nil
	}
	return c.IgnoreHeadersAndFooters
}

func (c *ChunkProcessing) GetTargetLength() *int {
	if c == nil {
		return nil
	}
	return c.TargetLength
}

func (c *ChunkProcessing) GetTokenizer() *TokenizerType {
	if c == nil {
		return nil
	}
	return c.Tokenizer
}

func (c *ChunkProcessing) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ChunkProcessing) UnmarshalJSON(data []byte) error {
	type unmarshaler ChunkProcessing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChunkProcessing(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChunkProcessing) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Configuration struct {
	ChunkProcessing *ChunkProcessing      `json:"chunk_processing" url:"chunk_processing"`
	ErrorHandling   ErrorHandlingStrategy `json:"error_handling" url:"error_handling"`
	// The number of seconds until task is deleted.
	// Expired tasks can **not** be updated, polled or accessed via web interface.
	ExpiresIn *int `json:"expires_in,omitempty" url:"expires_in,omitempty"`
	// Whether to use high-resolution images for cropping and post-processing.
	HighResolution bool `json:"high_resolution" url:"high_resolution"`
	// The presigned URL of the input file.
	InputFileUrl         *string              `json:"input_file_url,omitempty" url:"input_file_url,omitempty"`
	JsonSchema           interface{}          `json:"json_schema,omitempty" url:"json_schema,omitempty"`
	LlmProcessing        *LlmProcessing       `json:"llm_processing" url:"llm_processing"`
	Model                *Model               `json:"model,omitempty" url:"model,omitempty"`
	OcrStrategy          OcrStrategy          `json:"ocr_strategy" url:"ocr_strategy"`
	SegmentProcessing    *SegmentProcessing   `json:"segment_processing" url:"segment_processing"`
	SegmentationStrategy SegmentationStrategy `json:"segmentation_strategy" url:"segmentation_strategy"`
	// The target number of words in each chunk. If 0, each chunk will contain a single segment.
	TargetChunkLength *int `json:"target_chunk_length,omitempty" url:"target_chunk_length,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Configuration) GetChunkProcessing() *ChunkProcessing {
	if c == nil {
		return nil
	}
	return c.ChunkProcessing
}

func (c *Configuration) GetErrorHandling() ErrorHandlingStrategy {
	if c == nil {
		return ""
	}
	return c.ErrorHandling
}

func (c *Configuration) GetExpiresIn() *int {
	if c == nil {
		return nil
	}
	return c.ExpiresIn
}

func (c *Configuration) GetHighResolution() bool {
	if c == nil {
		return false
	}
	return c.HighResolution
}

func (c *Configuration) GetInputFileUrl() *string {
	if c == nil {
		return nil
	}
	return c.InputFileUrl
}

func (c *Configuration) GetJsonSchema() interface{} {
	if c == nil {
		return nil
	}
	return c.JsonSchema
}

func (c *Configuration) GetLlmProcessing() *LlmProcessing {
	if c == nil {
		return nil
	}
	return c.LlmProcessing
}

func (c *Configuration) GetModel() *Model {
	if c == nil {
		return nil
	}
	return c.Model
}

func (c *Configuration) GetOcrStrategy() OcrStrategy {
	if c == nil {
		return ""
	}
	return c.OcrStrategy
}

func (c *Configuration) GetSegmentProcessing() *SegmentProcessing {
	if c == nil {
		return nil
	}
	return c.SegmentProcessing
}

func (c *Configuration) GetSegmentationStrategy() SegmentationStrategy {
	if c == nil {
		return ""
	}
	return c.SegmentationStrategy
}

func (c *Configuration) GetTargetChunkLength() *int {
	if c == nil {
		return nil
	}
	return c.TargetChunkLength
}

func (c *Configuration) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Configuration) UnmarshalJSON(data []byte) error {
	type unmarshaler Configuration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Configuration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Configuration) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateFormMultipart struct {
	ChunkProcessing *ChunkProcessing `json:"chunk_processing,omitempty" url:"chunk_processing,omitempty"`
	// The number of seconds until task is deleted.
	// Expired tasks can **not** be updated, polled or accessed via web interface.
	ExpiresIn *int `json:"expires_in,omitempty" url:"expires_in,omitempty"`
	// The file to be uploaded.
	File string `json:"file" url:"file"`
	// Whether to use high-resolution images for cropping and post-processing. (Latency penalty: ~7 seconds per page)
	HighResolution       *bool                 `json:"high_resolution,omitempty" url:"high_resolution,omitempty"`
	OcrStrategy          *OcrStrategy          `json:"ocr_strategy,omitempty" url:"ocr_strategy,omitempty"`
	SegmentProcessing    *SegmentProcessing    `json:"segment_processing,omitempty" url:"segment_processing,omitempty"`
	SegmentationStrategy *SegmentationStrategy `json:"segmentation_strategy,omitempty" url:"segmentation_strategy,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CreateFormMultipart) GetChunkProcessing() *ChunkProcessing {
	if c == nil {
		return nil
	}
	return c.ChunkProcessing
}

func (c *CreateFormMultipart) GetExpiresIn() *int {
	if c == nil {
		return nil
	}
	return c.ExpiresIn
}

func (c *CreateFormMultipart) GetFile() string {
	if c == nil {
		return ""
	}
	return c.File
}

func (c *CreateFormMultipart) GetHighResolution() *bool {
	if c == nil {
		return nil
	}
	return c.HighResolution
}

func (c *CreateFormMultipart) GetOcrStrategy() *OcrStrategy {
	if c == nil {
		return nil
	}
	return c.OcrStrategy
}

func (c *CreateFormMultipart) GetSegmentProcessing() *SegmentProcessing {
	if c == nil {
		return nil
	}
	return c.SegmentProcessing
}

func (c *CreateFormMultipart) GetSegmentationStrategy() *SegmentationStrategy {
	if c == nil {
		return nil
	}
	return c.SegmentationStrategy
}

func (c *CreateFormMultipart) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CreateFormMultipart) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateFormMultipart
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateFormMultipart(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateFormMultipart) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Controls the cropping strategy for an item (e.g. segment, chunk, etc.)
// - `All` crops all images in the item
// - `Auto` crops images only if required for post-processing
type CroppingStrategy string

const (
	CroppingStrategyAll  CroppingStrategy = "All"
	CroppingStrategyAuto CroppingStrategy = "Auto"
)

func NewCroppingStrategyFromString(s string) (CroppingStrategy, error) {
	switch s {
	case "All":
		return CroppingStrategyAll, nil
	case "Auto":
		return CroppingStrategyAuto, nil
	}
	var t CroppingStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CroppingStrategy) Ptr() *CroppingStrategy {
	return &c
}

type EmbedSource string

const (
	EmbedSourceHtml     EmbedSource = "HTML"
	EmbedSourceMarkdown EmbedSource = "Markdown"
	EmbedSourceLlm      EmbedSource = "LLM"
	EmbedSourceContent  EmbedSource = "Content"
)

func NewEmbedSourceFromString(s string) (EmbedSource, error) {
	switch s {
	case "HTML":
		return EmbedSourceHtml, nil
	case "Markdown":
		return EmbedSourceMarkdown, nil
	case "LLM":
		return EmbedSourceLlm, nil
	case "Content":
		return EmbedSourceContent, nil
	}
	var t EmbedSource
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedSource) Ptr() *EmbedSource {
	return &e
}

// Controls how errors are handled during processing:
// - `Fail`: Stops processing and fails the task when any error occurs
// - `Continue`: Attempts to continue processing despite non-critical errors (eg. LLM refusals etc.)
type ErrorHandlingStrategy string

const (
	ErrorHandlingStrategyFail     ErrorHandlingStrategy = "Fail"
	ErrorHandlingStrategyContinue ErrorHandlingStrategy = "Continue"
)

func NewErrorHandlingStrategyFromString(s string) (ErrorHandlingStrategy, error) {
	switch s {
	case "Fail":
		return ErrorHandlingStrategyFail, nil
	case "Continue":
		return ErrorHandlingStrategyContinue, nil
	}
	var t ErrorHandlingStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorHandlingStrategy) Ptr() *ErrorHandlingStrategy {
	return &e
}

// Specifies the fallback strategy for LLM processing
//
// This can be:
// 1. None - No fallback will be used
// 2. Default - The system default fallback model will be used
// 3. Model - A specific model ID will be used as fallback (check the documentation for the models.)
type FallbackStrategy struct {
	NoneStringLiteral    string
	DefaultStringLiteral string
	// Use a specific model as fallback
	FallbackStrategyModel *FallbackStrategyModel

	typ string
}

func NewFallbackStrategyWithNoneStringLiteral() *FallbackStrategy {
	return &FallbackStrategy{typ: "NoneStringLiteral", NoneStringLiteral: "None"}
}

func NewFallbackStrategyWithDefaultStringLiteral() *FallbackStrategy {
	return &FallbackStrategy{typ: "DefaultStringLiteral", DefaultStringLiteral: "Default"}
}

func (f *FallbackStrategy) GetFallbackStrategyModel() *FallbackStrategyModel {
	if f == nil {
		return nil
	}
	return f.FallbackStrategyModel
}

func (f *FallbackStrategy) UnmarshalJSON(data []byte) error {
	var valueNoneStringLiteral string
	if err := json.Unmarshal(data, &valueNoneStringLiteral); err == nil {
		f.typ = "NoneStringLiteral"
		f.NoneStringLiteral = valueNoneStringLiteral
		if f.NoneStringLiteral != "None" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "None", valueNoneStringLiteral)
		}
		return nil
	}
	var valueDefaultStringLiteral string
	if err := json.Unmarshal(data, &valueDefaultStringLiteral); err == nil {
		f.typ = "DefaultStringLiteral"
		f.DefaultStringLiteral = valueDefaultStringLiteral
		if f.DefaultStringLiteral != "Default" {
			return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", f, "Default", valueDefaultStringLiteral)
		}
		return nil
	}
	valueFallbackStrategyModel := new(FallbackStrategyModel)
	if err := json.Unmarshal(data, &valueFallbackStrategyModel); err == nil {
		f.typ = "FallbackStrategyModel"
		f.FallbackStrategyModel = valueFallbackStrategyModel
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FallbackStrategy) MarshalJSON() ([]byte, error) {
	if f.typ == "NoneStringLiteral" || f.NoneStringLiteral != "" {
		return json.Marshal("None")
	}
	if f.typ == "DefaultStringLiteral" || f.DefaultStringLiteral != "" {
		return json.Marshal("Default")
	}
	if f.typ == "FallbackStrategyModel" || f.FallbackStrategyModel != nil {
		return json.Marshal(f.FallbackStrategyModel)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", f)
}

type FallbackStrategyVisitor interface {
	VisitNoneStringLiteral(string) error
	VisitDefaultStringLiteral(string) error
	VisitFallbackStrategyModel(*FallbackStrategyModel) error
}

func (f *FallbackStrategy) Accept(visitor FallbackStrategyVisitor) error {
	if f.typ == "NoneStringLiteral" || f.NoneStringLiteral != "" {
		return visitor.VisitNoneStringLiteral(f.NoneStringLiteral)
	}
	if f.typ == "DefaultStringLiteral" || f.DefaultStringLiteral != "" {
		return visitor.VisitDefaultStringLiteral(f.DefaultStringLiteral)
	}
	if f.typ == "FallbackStrategyModel" || f.FallbackStrategyModel != nil {
		return visitor.VisitFallbackStrategyModel(f.FallbackStrategyModel)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", f)
}

// Use a specific model as fallback
type FallbackStrategyModel struct {
	// Use a specific model as fallback
	Model string `json:"Model" url:"Model"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FallbackStrategyModel) GetModel() string {
	if f == nil {
		return ""
	}
	return f.Model
}

func (f *FallbackStrategyModel) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FallbackStrategyModel) UnmarshalJSON(data []byte) error {
	type unmarshaler FallbackStrategyModel
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FallbackStrategyModel(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FallbackStrategyModel) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type GenerationStrategy string

const (
	GenerationStrategyLlm  GenerationStrategy = "LLM"
	GenerationStrategyAuto GenerationStrategy = "Auto"
)

func NewGenerationStrategyFromString(s string) (GenerationStrategy, error) {
	switch s {
	case "LLM":
		return GenerationStrategyLlm, nil
	case "Auto":
		return GenerationStrategyAuto, nil
	}
	var t GenerationStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenerationStrategy) Ptr() *GenerationStrategy {
	return &g
}

// Controls the processing and generation for the segment.
//   - `crop_image` controls whether to crop the file's images to the segment's bounding box.
//     The cropped image will be stored in the segment's `image` field. Use `All` to always crop,
//     or `Auto` to only crop when needed for post-processing.
//   - `html` is the HTML output for the segment, generated either through huerstics (`Auto`) or using Chunkr fine-tuned models (`LLM`)
//   - `llm` is the LLM-generated output for the segment, this uses off-the-shelf models to generate a custom output for the segment
//   - `markdown` is the Markdown output for the segment, generated either through huerstics (`Auto`) or using Chunkr fine-tuned models (`LLM`)
//   - `embed_sources` defines which content sources will be included in the chunk's embed field and counted towards the chunk length.
//     The array's order determines the sequence in which content appears in the embed field (e.g., [Markdown, LLM] means Markdown content
//     is followed by LLM content). This directly affects what content is available for embedding and retrieval.
type LlmGenerationConfig struct {
	CropImage    *CroppingStrategy `json:"crop_image,omitempty" url:"crop_image,omitempty"`
	EmbedSources []EmbedSource     `json:"embed_sources,omitempty" url:"embed_sources,omitempty"`
	// Use the full page image as context for LLM generation
	ExtendedContext *bool               `json:"extended_context,omitempty" url:"extended_context,omitempty"`
	Html            *GenerationStrategy `json:"html,omitempty" url:"html,omitempty"`
	// Prompt for the LLM model
	Llm      *string             `json:"llm,omitempty" url:"llm,omitempty"`
	Markdown *GenerationStrategy `json:"markdown,omitempty" url:"markdown,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LlmGenerationConfig) GetCropImage() *CroppingStrategy {
	if l == nil {
		return nil
	}
	return l.CropImage
}

func (l *LlmGenerationConfig) GetEmbedSources() []EmbedSource {
	if l == nil {
		return nil
	}
	return l.EmbedSources
}

func (l *LlmGenerationConfig) GetExtendedContext() *bool {
	if l == nil {
		return nil
	}
	return l.ExtendedContext
}

func (l *LlmGenerationConfig) GetHtml() *GenerationStrategy {
	if l == nil {
		return nil
	}
	return l.Html
}

func (l *LlmGenerationConfig) GetLlm() *string {
	if l == nil {
		return nil
	}
	return l.Llm
}

func (l *LlmGenerationConfig) GetMarkdown() *GenerationStrategy {
	if l == nil {
		return nil
	}
	return l.Markdown
}

func (l *LlmGenerationConfig) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LlmGenerationConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler LlmGenerationConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LlmGenerationConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LlmGenerationConfig) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Controls the LLM used for the task.
type LlmProcessing struct {
	// The fallback strategy to use for the LLMs in the task.
	FallbackStrategy *FallbackStrategy `json:"fallback_strategy,omitempty" url:"fallback_strategy,omitempty"`
	// The maximum number of tokens to generate.
	MaxCompletionTokens *int `json:"max_completion_tokens,omitempty" url:"max_completion_tokens,omitempty"`
	// The ID of the model to use for the task. If not provided, the default model will be used.
	// Please check the documentation for the model you want to use.
	ModelId *string `json:"model_id,omitempty" url:"model_id,omitempty"`
	// The temperature to use for the LLM.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LlmProcessing) GetFallbackStrategy() *FallbackStrategy {
	if l == nil {
		return nil
	}
	return l.FallbackStrategy
}

func (l *LlmProcessing) GetMaxCompletionTokens() *int {
	if l == nil {
		return nil
	}
	return l.MaxCompletionTokens
}

func (l *LlmProcessing) GetModelId() *string {
	if l == nil {
		return nil
	}
	return l.ModelId
}

func (l *LlmProcessing) GetTemperature() *float64 {
	if l == nil {
		return nil
	}
	return l.Temperature
}

func (l *LlmProcessing) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LlmProcessing) UnmarshalJSON(data []byte) error {
	type unmarshaler LlmProcessing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LlmProcessing(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LlmProcessing) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Model string

const (
	ModelFast        Model = "Fast"
	ModelHighQuality Model = "HighQuality"
)

func NewModelFromString(s string) (Model, error) {
	switch s {
	case "Fast":
		return ModelFast, nil
	case "HighQuality":
		return ModelHighQuality, nil
	}
	var t Model
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m Model) Ptr() *Model {
	return &m
}

// OCR results for a segment
type OcrResult struct {
	Bbox *BoundingBox `json:"bbox" url:"bbox"`
	// The confidence score of the recognized text.
	Confidence *float64 `json:"confidence,omitempty" url:"confidence,omitempty"`
	// The recognized text of the OCR result.
	Text string `json:"text" url:"text"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OcrResult) GetBbox() *BoundingBox {
	if o == nil {
		return nil
	}
	return o.Bbox
}

func (o *OcrResult) GetConfidence() *float64 {
	if o == nil {
		return nil
	}
	return o.Confidence
}

func (o *OcrResult) GetText() string {
	if o == nil {
		return ""
	}
	return o.Text
}

func (o *OcrResult) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OcrResult) UnmarshalJSON(data []byte) error {
	type unmarshaler OcrResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OcrResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OcrResult) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Controls the Optical Character Recognition (OCR) strategy.
// - `All`: Processes all pages with OCR. (Latency penalty: ~0.5 seconds per page)
// - `Auto`: Selectively applies OCR only to pages with missing or low-quality text. When text layer is present the bounding boxes from the text layer are used.
type OcrStrategy string

const (
	OcrStrategyAll  OcrStrategy = "All"
	OcrStrategyAuto OcrStrategy = "Auto"
)

func NewOcrStrategyFromString(s string) (OcrStrategy, error) {
	switch s {
	case "All":
		return OcrStrategyAll, nil
	case "Auto":
		return OcrStrategyAuto, nil
	}
	var t OcrStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OcrStrategy) Ptr() *OcrStrategy {
	return &o
}

// The processed results of a document analysis task
type OutputResponse struct {
	// Collection of document chunks, where each chunk contains one or more segments
	Chunks        []*Chunk    `json:"chunks" url:"chunks"`
	ExtractedJson interface{} `json:"extracted_json,omitempty" url:"extracted_json,omitempty"`
	// The name of the file.
	FileName *string `json:"file_name,omitempty" url:"file_name,omitempty"`
	// The number of pages in the file.
	PageCount *int `json:"page_count,omitempty" url:"page_count,omitempty"`
	// The presigned URL of the PDF file.
	PdfUrl *string `json:"pdf_url,omitempty" url:"pdf_url,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OutputResponse) GetChunks() []*Chunk {
	if o == nil {
		return nil
	}
	return o.Chunks
}

func (o *OutputResponse) GetExtractedJson() interface{} {
	if o == nil {
		return nil
	}
	return o.ExtractedJson
}

func (o *OutputResponse) GetFileName() *string {
	if o == nil {
		return nil
	}
	return o.FileName
}

func (o *OutputResponse) GetPageCount() *int {
	if o == nil {
		return nil
	}
	return o.PageCount
}

func (o *OutputResponse) GetPdfUrl() *string {
	if o == nil {
		return nil
	}
	return o.PdfUrl
}

func (o *OutputResponse) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OutputResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OutputResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OutputResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OutputResponse) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// Controls the cropping strategy for an item (e.g. segment, chunk, etc.)
// - `All` crops all images in the item
// - `Auto` crops images only if required for post-processing
type PictureCroppingStrategy string

const (
	PictureCroppingStrategyAll  PictureCroppingStrategy = "All"
	PictureCroppingStrategyAuto PictureCroppingStrategy = "Auto"
)

func NewPictureCroppingStrategyFromString(s string) (PictureCroppingStrategy, error) {
	switch s {
	case "All":
		return PictureCroppingStrategyAll, nil
	case "Auto":
		return PictureCroppingStrategyAuto, nil
	}
	var t PictureCroppingStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PictureCroppingStrategy) Ptr() *PictureCroppingStrategy {
	return &p
}

// Controls the processing and generation for the segment.
//   - `crop_image` controls whether to crop the file's images to the segment's bounding box.
//     The cropped image will be stored in the segment's `image` field. Use `All` to always crop,
//     or `Auto` to only crop when needed for post-processing.
//   - `html` is the HTML output for the segment, generated either through heuristic (`Auto`) or using Chunkr fine-tuned models (`LLM`)
//   - `llm` is the LLM-generated output for the segment, this uses off-the-shelf models to generate a custom output for the segment
//   - `markdown` is the Markdown output for the segment, generated either through heuristic (`Auto`) or using Chunkr fine-tuned models (`LLM`)
//   - `embed_sources` defines which content sources will be included in the chunk's embed field and counted towards the chunk length.
//     The array's order determines the sequence in which content appears in the embed field (e.g., [Markdown, LLM] means Markdown content
//     is followed by LLM content). This directly affects what content is available for embedding and retrieval.
type PictureGenerationConfig struct {
	CropImage    *PictureCroppingStrategy `json:"crop_image,omitempty" url:"crop_image,omitempty"`
	EmbedSources []EmbedSource            `json:"embed_sources,omitempty" url:"embed_sources,omitempty"`
	// Use the full page image as context for LLM generation
	ExtendedContext *bool               `json:"extended_context,omitempty" url:"extended_context,omitempty"`
	Html            *GenerationStrategy `json:"html,omitempty" url:"html,omitempty"`
	// Prompt for the LLM model
	Llm      *string             `json:"llm,omitempty" url:"llm,omitempty"`
	Markdown *GenerationStrategy `json:"markdown,omitempty" url:"markdown,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PictureGenerationConfig) GetCropImage() *PictureCroppingStrategy {
	if p == nil {
		return nil
	}
	return p.CropImage
}

func (p *PictureGenerationConfig) GetEmbedSources() []EmbedSource {
	if p == nil {
		return nil
	}
	return p.EmbedSources
}

func (p *PictureGenerationConfig) GetExtendedContext() *bool {
	if p == nil {
		return nil
	}
	return p.ExtendedContext
}

func (p *PictureGenerationConfig) GetHtml() *GenerationStrategy {
	if p == nil {
		return nil
	}
	return p.Html
}

func (p *PictureGenerationConfig) GetLlm() *string {
	if p == nil {
		return nil
	}
	return p.Llm
}

func (p *PictureGenerationConfig) GetMarkdown() *GenerationStrategy {
	if p == nil {
		return nil
	}
	return p.Markdown
}

func (p *PictureGenerationConfig) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PictureGenerationConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler PictureGenerationConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PictureGenerationConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PictureGenerationConfig) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Segment struct {
	Bbox *BoundingBox `json:"bbox" url:"bbox"`
	// Confidence score of the layout analysis model
	Confidence *float64 `json:"confidence,omitempty" url:"confidence,omitempty"`
	// Text content of the segment. Calculated by the OCR results.
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// HTML representation of the segment.
	Html *string `json:"html,omitempty" url:"html,omitempty"`
	// Presigned URL to the image of the segment.
	Image *string `json:"image,omitempty" url:"image,omitempty"`
	// LLM representation of the segment.
	Llm *string `json:"llm,omitempty" url:"llm,omitempty"`
	// Markdown representation of the segment.
	Markdown *string `json:"markdown,omitempty" url:"markdown,omitempty"`
	// OCR results for the segment.
	Ocr []*OcrResult `json:"ocr,omitempty" url:"ocr,omitempty"`
	// Height of the page containing the segment.
	PageHeight float64 `json:"page_height" url:"page_height"`
	// Page number of the segment.
	PageNumber int `json:"page_number" url:"page_number"`
	// Width of the page containing the segment.
	PageWidth float64 `json:"page_width" url:"page_width"`
	// Unique identifier for the segment.
	SegmentId   string      `json:"segment_id" url:"segment_id"`
	SegmentType SegmentType `json:"segment_type" url:"segment_type"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Segment) GetBbox() *BoundingBox {
	if s == nil {
		return nil
	}
	return s.Bbox
}

func (s *Segment) GetConfidence() *float64 {
	if s == nil {
		return nil
	}
	return s.Confidence
}

func (s *Segment) GetContent() *string {
	if s == nil {
		return nil
	}
	return s.Content
}

func (s *Segment) GetHtml() *string {
	if s == nil {
		return nil
	}
	return s.Html
}

func (s *Segment) GetImage() *string {
	if s == nil {
		return nil
	}
	return s.Image
}

func (s *Segment) GetLlm() *string {
	if s == nil {
		return nil
	}
	return s.Llm
}

func (s *Segment) GetMarkdown() *string {
	if s == nil {
		return nil
	}
	return s.Markdown
}

func (s *Segment) GetOcr() []*OcrResult {
	if s == nil {
		return nil
	}
	return s.Ocr
}

func (s *Segment) GetPageHeight() float64 {
	if s == nil {
		return 0
	}
	return s.PageHeight
}

func (s *Segment) GetPageNumber() int {
	if s == nil {
		return 0
	}
	return s.PageNumber
}

func (s *Segment) GetPageWidth() float64 {
	if s == nil {
		return 0
	}
	return s.PageWidth
}

func (s *Segment) GetSegmentId() string {
	if s == nil {
		return ""
	}
	return s.SegmentId
}

func (s *Segment) GetSegmentType() SegmentType {
	if s == nil {
		return ""
	}
	return s.SegmentType
}

func (s *Segment) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Segment) UnmarshalJSON(data []byte) error {
	type unmarshaler Segment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Segment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Segment) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Controls the post-processing of each segment type.
// Allows you to generate HTML and Markdown from chunkr models for each segment type.
// By default, the HTML and Markdown are generated manually using the segmentation information except for `Table`, `Formula` and `Picture`.
// You can optionally configure custom LLM prompts and models to generate an additional `llm` field with LLM-processed content for each segment type.
//
// The configuration of which content sources (HTML, Markdown, LLM, Content) of the segment
// should be included in the chunk's `embed` field and counted towards the chunk length can be configured through the `embed_sources` setting.
type SegmentProcessing struct {
	Caption       *AutoGenerationConfig    `json:"Caption,omitempty" url:"Caption,omitempty"`
	Footnote      *AutoGenerationConfig    `json:"Footnote,omitempty" url:"Footnote,omitempty"`
	Formula       *LlmGenerationConfig     `json:"Formula,omitempty" url:"Formula,omitempty"`
	ListItem      *AutoGenerationConfig    `json:"ListItem,omitempty" url:"ListItem,omitempty"`
	Page          *LlmGenerationConfig     `json:"Page,omitempty" url:"Page,omitempty"`
	PageFooter    *AutoGenerationConfig    `json:"PageFooter,omitempty" url:"PageFooter,omitempty"`
	PageHeader    *AutoGenerationConfig    `json:"PageHeader,omitempty" url:"PageHeader,omitempty"`
	Picture       *PictureGenerationConfig `json:"Picture,omitempty" url:"Picture,omitempty"`
	SectionHeader *AutoGenerationConfig    `json:"SectionHeader,omitempty" url:"SectionHeader,omitempty"`
	Table         *LlmGenerationConfig     `json:"Table,omitempty" url:"Table,omitempty"`
	Text          *AutoGenerationConfig    `json:"Text,omitempty" url:"Text,omitempty"`
	Title         *AutoGenerationConfig    `json:"Title,omitempty" url:"Title,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SegmentProcessing) GetCaption() *AutoGenerationConfig {
	if s == nil {
		return nil
	}
	return s.Caption
}

func (s *SegmentProcessing) GetFootnote() *AutoGenerationConfig {
	if s == nil {
		return nil
	}
	return s.Footnote
}

func (s *SegmentProcessing) GetFormula() *LlmGenerationConfig {
	if s == nil {
		return nil
	}
	return s.Formula
}

func (s *SegmentProcessing) GetListItem() *AutoGenerationConfig {
	if s == nil {
		return nil
	}
	return s.ListItem
}

func (s *SegmentProcessing) GetPage() *LlmGenerationConfig {
	if s == nil {
		return nil
	}
	return s.Page
}

func (s *SegmentProcessing) GetPageFooter() *AutoGenerationConfig {
	if s == nil {
		return nil
	}
	return s.PageFooter
}

func (s *SegmentProcessing) GetPageHeader() *AutoGenerationConfig {
	if s == nil {
		return nil
	}
	return s.PageHeader
}

func (s *SegmentProcessing) GetPicture() *PictureGenerationConfig {
	if s == nil {
		return nil
	}
	return s.Picture
}

func (s *SegmentProcessing) GetSectionHeader() *AutoGenerationConfig {
	if s == nil {
		return nil
	}
	return s.SectionHeader
}

func (s *SegmentProcessing) GetTable() *LlmGenerationConfig {
	if s == nil {
		return nil
	}
	return s.Table
}

func (s *SegmentProcessing) GetText() *AutoGenerationConfig {
	if s == nil {
		return nil
	}
	return s.Text
}

func (s *SegmentProcessing) GetTitle() *AutoGenerationConfig {
	if s == nil {
		return nil
	}
	return s.Title
}

func (s *SegmentProcessing) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SegmentProcessing) UnmarshalJSON(data []byte) error {
	type unmarshaler SegmentProcessing
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SegmentProcessing(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SegmentProcessing) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// All the possible types for a segment.
// Note: Different configurations will produce different types.
// Please refer to the documentation for more information.
type SegmentType string

const (
	SegmentTypeCaption       SegmentType = "Caption"
	SegmentTypeFootnote      SegmentType = "Footnote"
	SegmentTypeFormula       SegmentType = "Formula"
	SegmentTypeListItem      SegmentType = "ListItem"
	SegmentTypePage          SegmentType = "Page"
	SegmentTypePageFooter    SegmentType = "PageFooter"
	SegmentTypePageHeader    SegmentType = "PageHeader"
	SegmentTypePicture       SegmentType = "Picture"
	SegmentTypeSectionHeader SegmentType = "SectionHeader"
	SegmentTypeTable         SegmentType = "Table"
	SegmentTypeText          SegmentType = "Text"
	SegmentTypeTitle         SegmentType = "Title"
)

func NewSegmentTypeFromString(s string) (SegmentType, error) {
	switch s {
	case "Caption":
		return SegmentTypeCaption, nil
	case "Footnote":
		return SegmentTypeFootnote, nil
	case "Formula":
		return SegmentTypeFormula, nil
	case "ListItem":
		return SegmentTypeListItem, nil
	case "Page":
		return SegmentTypePage, nil
	case "PageFooter":
		return SegmentTypePageFooter, nil
	case "PageHeader":
		return SegmentTypePageHeader, nil
	case "Picture":
		return SegmentTypePicture, nil
	case "SectionHeader":
		return SegmentTypeSectionHeader, nil
	case "Table":
		return SegmentTypeTable, nil
	case "Text":
		return SegmentTypeText, nil
	case "Title":
		return SegmentTypeTitle, nil
	}
	var t SegmentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SegmentType) Ptr() *SegmentType {
	return &s
}

// Controls the segmentation strategy:
// - `LayoutAnalysis`: Analyzes pages for layout elements (e.g., `Table`, `Picture`, `Formula`, etc.) using bounding boxes. Provides fine-grained segmentation and better chunking. (Latency penalty: ~TBD seconds per page).
// - `Page`: Treats each page as a single segment. Faster processing, but without layout element detection and only simple chunking.
type SegmentationStrategy string

const (
	SegmentationStrategyLayoutAnalysis SegmentationStrategy = "LayoutAnalysis"
	SegmentationStrategyPage           SegmentationStrategy = "Page"
)

func NewSegmentationStrategyFromString(s string) (SegmentationStrategy, error) {
	switch s {
	case "LayoutAnalysis":
		return SegmentationStrategyLayoutAnalysis, nil
	case "Page":
		return SegmentationStrategyPage, nil
	}
	var t SegmentationStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SegmentationStrategy) Ptr() *SegmentationStrategy {
	return &s
}

// The status of the task.
type Status string

const (
	StatusStarting   Status = "Starting"
	StatusProcessing Status = "Processing"
	StatusSucceeded  Status = "Succeeded"
	StatusFailed     Status = "Failed"
	StatusCancelled  Status = "Cancelled"
)

func NewStatusFromString(s string) (Status, error) {
	switch s {
	case "Starting":
		return StatusStarting, nil
	case "Processing":
		return StatusProcessing, nil
	case "Succeeded":
		return StatusSucceeded, nil
	case "Failed":
		return StatusFailed, nil
	case "Cancelled":
		return StatusCancelled, nil
	}
	var t Status
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s Status) Ptr() *Status {
	return &s
}

type TaskResponse struct {
	Configuration *Configuration `json:"configuration" url:"configuration"`
	// The date and time when the task was created and queued.
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// The date and time when the task will expire.
	ExpiresAt *time.Time `json:"expires_at,omitempty" url:"expires_at,omitempty"`
	// The date and time when the task was finished.
	FinishedAt *time.Time `json:"finished_at,omitempty" url:"finished_at,omitempty"`
	// A message describing the task's status or any errors that occurred.
	Message string          `json:"message" url:"message"`
	Output  *OutputResponse `json:"output,omitempty" url:"output,omitempty"`
	// The date and time when the task was started.
	StartedAt *time.Time `json:"started_at,omitempty" url:"started_at,omitempty"`
	Status    Status     `json:"status" url:"status"`
	// The unique identifier for the task.
	TaskId string `json:"task_id" url:"task_id"`
	// The presigned URL of the task.
	TaskUrl *string `json:"task_url,omitempty" url:"task_url,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TaskResponse) GetConfiguration() *Configuration {
	if t == nil {
		return nil
	}
	return t.Configuration
}

func (t *TaskResponse) GetCreatedAt() time.Time {
	if t == nil {
		return time.Time{}
	}
	return t.CreatedAt
}

func (t *TaskResponse) GetExpiresAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.ExpiresAt
}

func (t *TaskResponse) GetFinishedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.FinishedAt
}

func (t *TaskResponse) GetMessage() string {
	if t == nil {
		return ""
	}
	return t.Message
}

func (t *TaskResponse) GetOutput() *OutputResponse {
	if t == nil {
		return nil
	}
	return t.Output
}

func (t *TaskResponse) GetStartedAt() *time.Time {
	if t == nil {
		return nil
	}
	return t.StartedAt
}

func (t *TaskResponse) GetStatus() Status {
	if t == nil {
		return ""
	}
	return t.Status
}

func (t *TaskResponse) GetTaskId() string {
	if t == nil {
		return ""
	}
	return t.TaskId
}

func (t *TaskResponse) GetTaskUrl() *string {
	if t == nil {
		return nil
	}
	return t.TaskUrl
}

func (t *TaskResponse) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TaskResponse) UnmarshalJSON(data []byte) error {
	type embed TaskResponse
	var unmarshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at"`
		ExpiresAt  *internal.DateTime `json:"expires_at,omitempty"`
		FinishedAt *internal.DateTime `json:"finished_at,omitempty"`
		StartedAt  *internal.DateTime `json:"started_at,omitempty"`
	}{
		embed: embed(*t),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*t = TaskResponse(unmarshaler.embed)
	t.CreatedAt = unmarshaler.CreatedAt.Time()
	t.ExpiresAt = unmarshaler.ExpiresAt.TimePtr()
	t.FinishedAt = unmarshaler.FinishedAt.TimePtr()
	t.StartedAt = unmarshaler.StartedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TaskResponse) MarshalJSON() ([]byte, error) {
	type embed TaskResponse
	var marshaler = struct {
		embed
		CreatedAt  *internal.DateTime `json:"created_at"`
		ExpiresAt  *internal.DateTime `json:"expires_at,omitempty"`
		FinishedAt *internal.DateTime `json:"finished_at,omitempty"`
		StartedAt  *internal.DateTime `json:"started_at,omitempty"`
	}{
		embed:      embed(*t),
		CreatedAt:  internal.NewDateTime(t.CreatedAt),
		ExpiresAt:  internal.NewOptionalDateTime(t.ExpiresAt),
		FinishedAt: internal.NewOptionalDateTime(t.FinishedAt),
		StartedAt:  internal.NewOptionalDateTime(t.StartedAt),
	}
	return json.Marshal(marshaler)
}

func (t *TaskResponse) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Common tokenizers used for text processing.
//
// These values represent standard tokenization approaches and popular pre-trained
// tokenizers from the Hugging Face ecosystem.
type Tokenizer string

const (
	TokenizerWord            Tokenizer = "Word"
	TokenizerCl100KBase      Tokenizer = "Cl100kBase"
	TokenizerXlmRobertaBase  Tokenizer = "XlmRobertaBase"
	TokenizerBertBaseUncased Tokenizer = "BertBaseUncased"
)

func NewTokenizerFromString(s string) (Tokenizer, error) {
	switch s {
	case "Word":
		return TokenizerWord, nil
	case "Cl100kBase":
		return TokenizerCl100KBase, nil
	case "XlmRobertaBase":
		return TokenizerXlmRobertaBase, nil
	case "BertBaseUncased":
		return TokenizerBertBaseUncased, nil
	}
	var t Tokenizer
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t Tokenizer) Ptr() *Tokenizer {
	return &t
}

// Specifies which tokenizer to use for the chunking process.
//
// This type supports two ways of specifying a tokenizer:
//  1. Using a predefined tokenizer from the `Tokenizer` enum
//  2. Using any Hugging Face tokenizer by providing its model ID as a string
//     (e.g. "facebook/bart-large", "Qwen/Qwen-tokenizer", etc.)
//
// When using a string, any valid Hugging Face tokenizer ID can be specified,
// which will be loaded using the Hugging Face tokenizers library.
type TokenizerType struct {
	// Use one of the predefined tokenizer types
	TokenizerTypeEnum *TokenizerTypeEnum
	// Use any Hugging Face tokenizer by specifying its model ID
	// Examples: "Qwen/Qwen-tokenizer", "facebook/bart-large"
	TokenizerTypeString *TokenizerTypeString

	typ string
}

func (t *TokenizerType) GetTokenizerTypeEnum() *TokenizerTypeEnum {
	if t == nil {
		return nil
	}
	return t.TokenizerTypeEnum
}

func (t *TokenizerType) GetTokenizerTypeString() *TokenizerTypeString {
	if t == nil {
		return nil
	}
	return t.TokenizerTypeString
}

func (t *TokenizerType) UnmarshalJSON(data []byte) error {
	valueTokenizerTypeEnum := new(TokenizerTypeEnum)
	if err := json.Unmarshal(data, &valueTokenizerTypeEnum); err == nil {
		t.typ = "TokenizerTypeEnum"
		t.TokenizerTypeEnum = valueTokenizerTypeEnum
		return nil
	}
	valueTokenizerTypeString := new(TokenizerTypeString)
	if err := json.Unmarshal(data, &valueTokenizerTypeString); err == nil {
		t.typ = "TokenizerTypeString"
		t.TokenizerTypeString = valueTokenizerTypeString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TokenizerType) MarshalJSON() ([]byte, error) {
	if t.typ == "TokenizerTypeEnum" || t.TokenizerTypeEnum != nil {
		return json.Marshal(t.TokenizerTypeEnum)
	}
	if t.typ == "TokenizerTypeString" || t.TokenizerTypeString != nil {
		return json.Marshal(t.TokenizerTypeString)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", t)
}

type TokenizerTypeVisitor interface {
	VisitTokenizerTypeEnum(*TokenizerTypeEnum) error
	VisitTokenizerTypeString(*TokenizerTypeString) error
}

func (t *TokenizerType) Accept(visitor TokenizerTypeVisitor) error {
	if t.typ == "TokenizerTypeEnum" || t.TokenizerTypeEnum != nil {
		return visitor.VisitTokenizerTypeEnum(t.TokenizerTypeEnum)
	}
	if t.typ == "TokenizerTypeString" || t.TokenizerTypeString != nil {
		return visitor.VisitTokenizerTypeString(t.TokenizerTypeString)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", t)
}

// Use one of the predefined tokenizer types
type TokenizerTypeEnum struct {
	// Use one of the predefined tokenizer types
	Enum Tokenizer `json:"Enum" url:"Enum"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenizerTypeEnum) GetEnum() Tokenizer {
	if t == nil {
		return ""
	}
	return t.Enum
}

func (t *TokenizerTypeEnum) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenizerTypeEnum) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenizerTypeEnum
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenizerTypeEnum(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenizerTypeEnum) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Use any Hugging Face tokenizer by specifying its model ID
// Examples: "Qwen/Qwen-tokenizer", "facebook/bart-large"
type TokenizerTypeString struct {
	// Use any Hugging Face tokenizer by specifying its model ID
	// Examples: "Qwen/Qwen-tokenizer", "facebook/bart-large"
	Str string `json:"String" url:"String"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TokenizerTypeString) GetString() string {
	if t == nil {
		return ""
	}
	return t.Str
}

func (t *TokenizerTypeString) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenizerTypeString) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenizerTypeString
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenizerTypeString(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenizerTypeString) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type UpdateFormMultipart struct {
	ChunkProcessing *ChunkProcessing `json:"chunk_processing,omitempty" url:"chunk_processing,omitempty"`
	// The number of seconds until task is deleted.
	// Expried tasks can **not** be updated, polled or accessed via web interface.
	ExpiresIn *int `json:"expires_in,omitempty" url:"expires_in,omitempty"`
	// Whether to use high-resolution images for cropping and post-processing. (Latency penalty: ~7 seconds per page)
	HighResolution       *bool                 `json:"high_resolution,omitempty" url:"high_resolution,omitempty"`
	OcrStrategy          *OcrStrategy          `json:"ocr_strategy,omitempty" url:"ocr_strategy,omitempty"`
	SegmentProcessing    *SegmentProcessing    `json:"segment_processing,omitempty" url:"segment_processing,omitempty"`
	SegmentationStrategy *SegmentationStrategy `json:"segmentation_strategy,omitempty" url:"segmentation_strategy,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateFormMultipart) GetChunkProcessing() *ChunkProcessing {
	if u == nil {
		return nil
	}
	return u.ChunkProcessing
}

func (u *UpdateFormMultipart) GetExpiresIn() *int {
	if u == nil {
		return nil
	}
	return u.ExpiresIn
}

func (u *UpdateFormMultipart) GetHighResolution() *bool {
	if u == nil {
		return nil
	}
	return u.HighResolution
}

func (u *UpdateFormMultipart) GetOcrStrategy() *OcrStrategy {
	if u == nil {
		return nil
	}
	return u.OcrStrategy
}

func (u *UpdateFormMultipart) GetSegmentProcessing() *SegmentProcessing {
	if u == nil {
		return nil
	}
	return u.SegmentProcessing
}

func (u *UpdateFormMultipart) GetSegmentationStrategy() *SegmentationStrategy {
	if u == nil {
		return nil
	}
	return u.SegmentationStrategy
}

func (u *UpdateFormMultipart) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateFormMultipart) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateFormMultipart
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateFormMultipart(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateFormMultipart) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
